import pandas as pd
import numpy as np
from pmdarima import auto_arima
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_absolute_error, mean_squared_error
import warnings
warnings.filterwarnings('ignore')

def calculate_mape(actual, predicted):
    """Calculate Mean Absolute Percentage Error"""
    actual, predicted = np.array(actual), np.array(predicted)
    return np.mean(np.abs((actual - predicted) / actual)) * 100

def get_model_metrics(model_fit):
    """Extract model performance metrics"""
    try:
        return {
            "aic": float(model_fit.aic()),
            "bic": float(model_fit.bic()),
            "aicc": float(model_fit.aicc()) if hasattr(model_fit, 'aicc') else None
        }
    except:
        return {"aic": None, "bic": None, "aicc": None}

def run_sarima(series, seasonal=True, m=12, steps=6):
    """
    Legacy function - Fits SARIMA/ARIMA on a pandas Series and returns forecast with confidence intervals.
    """
    model = auto_arima(
        series,
        seasonal=seasonal,
        m=m,
        suppress_warnings=True,
        error_action="ignore"
    )
    forecast, conf_int = model.predict(n_periods=steps, return_conf_int=True)

    return {
        "order": model.order,
        "seasonal_order": model.seasonal_order,
        "forecast": forecast.tolist(),
        "lower": conf_int[:, 0].tolist(),
        "upper": conf_int[:, 1].tolist()
    }

def run_auto_forecast(series, seasonal=True, seasonal_period=None, steps=6, confidence_level=0.95):
    """
    Automatic SARIMA/ARIMA model selection and forecasting.
    
    Args:
        series: pandas Series with time series data
        seasonal: bool, whether to use seasonal model
        seasonal_period: int, seasonal period (None for auto-detect)
        steps: int, number of periods to forecast
        confidence_level: float, confidence level for intervals
    
    Returns:
        dict with forecast, confidence intervals, and model info
    """
    # Auto-detect seasonal period if not provided
    if seasonal and seasonal_period is None:
        # Common seasonal periods: 12 (monthly), 4 (quarterly), 7 (daily/weekly)
        seasonal_period = 12 if len(series) >= 24 else None
        if seasonal_period is None:
            seasonal = False
    
    # Ensure m is an integer
    m_value = int(seasonal_period) if seasonal and seasonal_period else 1
    
    # Fit auto_arima model
    model = auto_arima(
        series,
        seasonal=seasonal,
        m=m_value,
        start_p=0, start_q=0,
        max_p=5, max_q=5,
        start_P=0, start_Q=0,
        max_P=2, max_Q=2,
        d=None, D=None,
        trace=False,
        error_action='ignore',
        suppress_warnings=True,
        stepwise=True,
        random_state=42
    )
    
    # Generate forecast with confidence intervals
    alpha = 1 - confidence_level
    forecast, conf_int = model.predict(n_periods=steps, return_conf_int=True, alpha=alpha)
    
    # Get model metrics
    metrics = get_model_metrics(model)
    
    return {
        "order": model.order,
        "seasonal_order": model.seasonal_order if seasonal else (0, 0, 0, 0),
        "forecast": forecast.tolist(),
        "lower": conf_int[:, 0].tolist(),
        "upper": conf_int[:, 1].tolist(),
        "metrics": metrics
    }

def run_manual_forecast(series, order, seasonal_order=None, steps=6, confidence_level=0.95):
    """
    Manual SARIMA/ARIMA forecasting with specified parameters.
    
    Args:
        series: pandas Series with time series data
        order: tuple (p, d, q) for ARIMA
        seasonal_order: tuple (P, D, Q, m) for seasonal component
        steps: int, number of periods to forecast
        confidence_level: float, confidence level for intervals
    
    Returns:
        dict with forecast, confidence intervals, and model info
    """
    # Fit SARIMAX model
    model = SARIMAX(
        series,
        order=order,
        seasonal_order=seasonal_order if seasonal_order else (0, 0, 0, 0),
        enforce_stationarity=False,
        enforce_invertibility=False
    )
    
    model_fit = model.fit(disp=False)
    
    # Generate forecast
    alpha = 1 - confidence_level
    forecast_result = model_fit.get_forecast(steps=steps, alpha=alpha)
    forecast = forecast_result.predicted_mean
    conf_int = forecast_result.conf_int()
    
    # Get model metrics
    metrics = get_model_metrics(model_fit)
    
    return {
        "forecast": forecast.tolist(),
        "lower": conf_int.iloc[:, 0].tolist(),
        "upper": conf_int.iloc[:, 1].tolist(),
        "metrics": metrics
    }

def evaluate_forecast(series, test_size=6, seasonal=True, seasonal_period=None):
    """
    Evaluate forecast model accuracy using train-test split.
    
    Args:
        series: pandas Series with time series data
        test_size: int, number of periods for testing
        seasonal: bool, whether to use seasonal model
        seasonal_period: int, seasonal period
    
    Returns:
        dict with predictions, actual values, and error metrics
    """
    if len(series) < test_size + 10:
        raise ValueError(f"Series too short for test_size={test_size}. Need at least {test_size + 10} observations.")
    
    # Split data
    train = series[:-test_size]
    test = series[-test_size:]
    
    # Auto-detect seasonal period if not provided
    seasonal_period_value = None
    if seasonal and seasonal_period is None:
        seasonal_period_value = 12 if len(train) >= 24 else None
        if seasonal_period_value is None:
            seasonal = False
    elif seasonal_period is not None:
        seasonal_period_value = seasonal_period
    
    m_value = int(seasonal_period_value) if seasonal and seasonal_period_value else 1
    
    # Fit model on training data
    model = auto_arima(
        train,
        seasonal=seasonal,
        m=m_value,
        suppress_warnings=True,
        error_action='ignore',
        stepwise=True
    )
    
    # Predict test period
    predictions, _ = model.predict(n_periods=test_size, return_conf_int=True)
    
    # Calculate error metrics
    mae = mean_absolute_error(test, predictions)
    rmse = np.sqrt(mean_squared_error(test, predictions))
    mape = calculate_mape(test, predictions)
    
    model_name = f"SARIMA{model.order}x{model.seasonal_order}" if seasonal else f"ARIMA{model.order}"
    
    return {
        "model_name": model_name,
        "predictions": predictions.tolist(),
        "actual": test.tolist(),
        "metrics": {
            "mae": float(mae),
            "rmse": float(rmse),
            "mape": float(mape),
            "aic": float(model.aic()),
            "bic": float(model.bic())
        },
        "train_size": len(train)
    }

# ============================================
# BUSINESS-SPECIFIC FORECASTING FUNCTIONS
# ============================================

def forecast_ingredient_usage(series, steps=7, seasonal=True, seasonal_period=7):
    """
    Forecast ingredient usage for inventory management.
    
    Args:
        series: pandas Series with daily usage data
        steps: int, number of days to forecast
        seasonal: bool, account for weekly patterns
        seasonal_period: int, seasonality (7 for weekly)
    
    Returns:
        dict with usage forecast and inventory metrics
    """
    # Auto-detect seasonal period if data is sufficient
    if seasonal and len(series) < seasonal_period * 2:
        seasonal = False
    
    m_value = int(seasonal_period) if seasonal else 1
    
    # Fit model
    model = auto_arima(
        series,
        seasonal=seasonal,
        m=m_value,
        start_p=0, start_q=0,
        max_p=3, max_q=3,
        start_P=0, start_Q=0,
        max_P=2, max_Q=2,
        suppress_warnings=True,
        error_action='ignore',
        stepwise=True
    )
        start_p=0, start_q=0,
        max_p=3, max_q=3,
        start_P=0, start_Q=0,
        max_P=2, max_Q=2,
        suppress_warnings=True,
        error_action='ignore',
        stepwise=True
    )
    
    # Generate forecast
    forecast, conf_int = model.predict(n_periods=steps, return_conf_int=True)
    
    # Calculate metrics
    total_usage = float(np.sum(forecast))
    avg_daily = float(np.mean(forecast))
    peak_day = int(np.argmax(forecast)) + 1
    
    model_name = f"SARIMA{model.order}x{model.seasonal_order}" if seasonal else f"ARIMA{model.order}"
    
    return {
        "forecast": forecast.tolist(),
        "lower": conf_int[:, 0].tolist(),
        "upper": conf_int[:, 1].tolist(),
        "total_usage": total_usage,
        "avg_daily_usage": avg_daily,
        "peak_day": peak_day,
        "model_name": model_name,
        "metrics": get_model_metrics(model)
    }

def forecast_category_demand(series, steps=30, seasonal=True):
    """
    Forecast demand for a product category.
    
    Args:
        series: pandas Series with historical demand
        steps: int, number of periods to forecast
        seasonal: bool, account for seasonality
    
    Returns:
        dict with demand forecast and trend analysis
    """
    # Determine seasonal period based on data frequency
    seasonal_period = 7 if len(series) >= 14 else None
    if not seasonal_period:
    m_value = int(seasonal_period) if seasonal and seasonal_period else 1
    
    # Fit model
    model = auto_arima(
        series,
        seasonal=seasonal,
        m=m_value
        seasonal=seasonal,
        m=seasonal_period if seasonal else 1,
        suppress_warnings=True,
        error_action='ignore',
        stepwise=True
    )
    
    # Generate forecast
    forecast, conf_int = model.predict(n_periods=steps, return_conf_int=True)
    
    # Calculate trend (positive = growing, negative = declining)
    trend_direction = "growing" if forecast[-1] > forecast[0] else "declining"
    trend_percentage = ((forecast[-1] - forecast[0]) / forecast[0]) * 100 if forecast[0] != 0 else 0
    
    total_demand = float(np.sum(forecast))
    
    model_name = f"SARIMA{model.order}x{model.seasonal_order}" if seasonal else f"ARIMA{model.order}"
    
    return {
        "forecast": forecast.tolist(),
        "lower": conf_int[:, 0].tolist(),
        "upper": conf_int[:, 1].tolist(),
        "total_demand": total_demand,
        "trend": {
            "direction": trend_direction,
            "percentage": float(trend_percentage)
        },
        "model_name": model_name,
        "metrics": get_model_metrics(model)
    }

def forecast_revenue(series, steps=6, seasonal=True):
    """
    Forecast total sales revenue.
    
    Args:
        series: pandas Series with monthly revenue
        steps: int, number of months to forecast
        seasonal: bool, account for seasonality
    
    Returns:
        dict with revenue forecast and financial metrics
    """
    # Determine seasonal period (monthly = 12)
    m_value = int(seasonal_period) if seasonal and seasonal_period else 1
    
    # Fit model
    model = auto_arima(
        series,
        seasonal=seasonal,
        m=m_value
    model = auto_arima(
        series,
        seasonal=seasonal,
        m=seasonal_period if seasonal else 1,
        start_p=0, start_q=0,
        max_p=5, max_q=5,
        suppress_warnings=True,
        error_action='ignore',
        stepwise=True
    )
    
    # Generate forecast
    forecast, conf_int = model.predict(n_periods=steps, return_conf_int=True)
    
    # Calculate financial metrics
    total_revenue = float(np.sum(forecast))
    avg_monthly = float(np.mean(forecast))
    
    # Growth rate calculation
    if len(series) >= 2:
        recent_avg = float(series.tail(3).mean())
        forecast_avg = float(forecast.mean())
        growth_rate = ((forecast_avg - recent_avg) / recent_avg) * 100 if recent_avg != 0 else 0
    else:
        growth_rate = 0.0
    
    # Trend analysis
    trend_direction = "increasing" if forecast[-1] > forecast[0] else "decreasing"
    
    model_name = f"SARIMA{model.order}x{model.seasonal_order}" if seasonal else f"ARIMA{model.order}"
    
    return {
        "forecast": forecast.tolist(),
        "lower": conf_int[:, 0].tolist(),
        "upper": conf_int[:, 1].tolist(),
        "total_revenue": total_revenue,
        "avg_monthly_revenue": avg_monthly,
        "growth_rate": float(growth_rate),
        "trend": trend_direction,
        "model_name": model_name,
        "metrics": get_model_metrics(model)
    }

def calculate_reorder_alert(series, current_stock, reorder_point, lead_time_days=3, safety_stock=0.0):
    """
    Calculate reorder alerts based on forecasted usage.
    
    Args:
        series: pandas Series with usage history
        current_stock: float, current inventory level
        reorder_point: float, stock level to trigger reorder
        lead_time_days: int, days to receive new stock
        safety_stock: float, buffer stock level
    
    Returns:
        dict with alert status and recommendations
    """
    # Forecast usage for next 30 days
    try:m_value = int(seasonal_period)
        
        model = auto_arima(
            series,
            seasonal=seasonal,
            m=m_value
        model = auto_arima(
            series,
            seasonal=seasonal,
            m=seasonal_period,
            start_p=0, start_q=0,
            max_p=3, max_q=3,
            suppress_warnings=True,
            error_action='ignore',
            stepwise=True
        )
        
        forecast_30, _ = model.predict(n_periods=30, return_conf_int=True)
        
    except:
        # Fallback to simple average if model fails
        avg_usage = series.mean()
        forecast_30 = np.array([avg_usage] * 30)
    
    # Calculate cumulative usage
    cumulative_usage = np.cumsum(forecast_30)
    
    # Find when stock hits reorder point
    stock_levels = current_stock - cumulative_usage
    reorder_threshold = reorder_point + safety_stock
    
    days_until_reorder = None
    days_until_stockout = None
    
    for day, stock_level in enumerate(stock_levels, 1):
        if days_until_reorder is None and stock_level <= reorder_threshold:
            days_until_reorder = day
        if days_until_stockout is None and stock_level <= 0:
            days_until_stockout = day
    
    # If never hits reorder point in 30 days
    if days_until_reorder is None:
        days_until_reorder = 30
    if days_until_stockout is None:
        days_until_stockout = 30
    
    # Determine alert status
    if current_stock <= reorder_point:
        alert_status = "CRITICAL"
        should_reorder = True
        priority = "HIGH"
        message = f"Stock is at or below reorder point. Order immediately!"
    elif days_until_reorder <= lead_time_days:
        alert_status = "WARNING"
        should_reorder = True
        priority = "MEDIUM"
        message = f"Stock will hit reorder point in {days_until_reorder} days. Order now to avoid stockout."
    elif days_until_reorder <= (lead_time_days * 2):
        alert_status = "ATTENTION"
        should_reorder = False
        priority = "LOW"
        message = f"Stock will hit reorder point in {days_until_reorder} days. Monitor closely."
    else:
        alert_status = "OK"
        should_reorder = False
        priority = "NONE"
        message = f"Stock levels are healthy. Reorder needed in {days_until_reorder} days."
    
    # Calculate recommended order quantity
    # Order enough for lead time + safety period
    safety_period = 7  # Extra week of stock
    total_forecast_period = lead_time_days + safety_period
    forecasted_usage_during_leadtime = float(np.sum(forecast_30[:total_forecast_period]))
    recommended_order = max(0, forecasted_usage_during_leadtime - (current_stock - reorder_point) + safety_stock)
    
    # Usage summaries
    usage_7 = float(np.sum(forecast_30[:7]))
    usage_14 = float(np.sum(forecast_30[:14]))
    usage_30 = float(np.sum(forecast_30[:30]))
    
    return {
        "alert_status": alert_status,
        "should_reorder": should_reorder,
        "days_until_reorder": int(days_until_reorder),
        "days_until_stockout": int(days_until_stockout) if days_until_stockout < 30 else None,
        "recommended_order_qty": float(recommended_order),
        "usage_next_7_days": usage_7,
        "usage_next_14_days": usage_14,
        "usage_next_30_days": usage_30,
        "message": message,
        "priority": priority
    }
